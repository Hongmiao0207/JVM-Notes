# JVM

一 内存与垃圾回收
====

1、JVM与Java体系结构
----

**java比c++优势**：内存动态分配、垃圾收集技术

**jvm字节码**：特定的二进制文件格式，class文件格式所关联。各种语言通过编译器编译生成的可以供虚拟机识别的语言，比如java编译器。不同语言的编译器编译成相同的字节码然后在jvm上运行。所以jvm现在已经不单独属于java。
![](../JVM_Pictures/Snipaste_2022-01-29_15-01-28.png)

**多语言混合编程**：由于越来越多的语言都开始支持在jvm上运行，多语言混合变成开始成为主流。比如，一个项目中，处理层用Clojure，展示层用Jruby/Rails，中间层用Java。每个应用层都使用不同的语言来完成。由于大家都运行在jvm上，所以跨语言之间的交互和调用就像调用自己语言中的api一样。

## 1.1 虚拟机和Java虚拟机
虚拟机：系统虚拟机：VMwware、Visual Box；成虚拟机：JVM
Java虚拟机：
1. 作用：执行字节码，二进制字节码的运行环境，负责装字节码到其内部，解释/编译对应平台的机器指令。每个指令，在java虚拟机规范中都有说明。
2. 特点：一次编译、到处运行；自动内存管理；自动垃圾回收功能


## 1.2 JVM整体结构
**HotSpot VM** 是主流高性能虚拟机的代表作之一，采用解释器与即时编译器并存的架构
![](../JVM_Pictures/Snipaste_2022-01-29_16-37-24.png)
**Class Loader**就是将class files加载到内存当中，生成一个大的class对象，过程中涉及到加载、链接和初始化。

**Runtime Data Area**中，方法区和堆是多线程共享的，Java Stack(VM Stack), Native Method Stack and Program Counter Register是每个线程独一份的

**Execution Engine** 有三个部分，Interpreter(解释器), JIT Compiler(即时编译器) and Garbage Collection(垃圾回收器)

## 1.3 Java代码执行流程

![](../JVM_Pictures/Snipaste_2022-01-29_16-47-04.png)

![](../JVM_Pictures/Snipaste_2022-01-29_16-47-59.png)
其中，JIT编译器主要负责提升编译速度，因为有些数据希望是热启动，比如放在缓存中，达到随用随取，而不是用时再编译。

![](../JVM_Pictures/Snipaste_2022-01-29_16-50-59.png)

## 1.4 JVM架构模型

HotSpot基于的是栈的指令集架构。因为要实现跨平台就不能基于寄存器，因为不用平台cpu架构不同，这就导致性能下降，实现同样功能需要更多的指令。

Java编译器输入的两种指令流：
1. 栈的指令集结构
2. 寄存器的指令集架构
3. 二者区别：
   1. 基于栈式架构的特点：
      1. 设计和实现**更简单**，适用于**资源受限的系统**
      2. 避开了寄存器的分配难题：使用**零地址指**令方式分配
      3. 指令流中的指令大部分是零地址指令，起执行过程中**依赖于操作栈**。指令集更小。编译器更容易实现。
      4. 不需要硬件支持、**可移植性更好**、更好实现跨平台
   2. 基于寄存器架构特点：
      1. 典型的应用于x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机
      2. 指令架构则完全依赖硬件、可移植性差
      3. 性能优秀和执行更高效
      4. 花费更少的指令去完成一项操作
      5. 在大部分情况下，基于寄存器架构的指令集往往都以**一地指令、二地址指令和三地址指令为主**，而基于栈式架构的指令集却以零地址指令为主。

零地址指令是没有地址，只有操作数

## 1.5 JVM生命周期
1. 启动，通过**引导类加载器**(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类由虚拟机得具体实现指定的。
2. 执行，程序开始执行的时候才运行，程序结束时它就结束。执行一个所谓java程序的时候，真真正正在执行的是一个叫做java虚拟机的进程。
3. 退出：
   1.  程序正常执行结束；
   2.  程序在执行过程中遇到了异常或错误而异常终止；
   3.  由于操作系统出现错误导致java虚拟机进程终止；
   4. 某线程调用Runtime类或System的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。

2、类加载器子系统 (Class Loader SubSystem)
----

![](../JVM_Pictures/Snipaste_2022-01-30_15-56-35.png)

类的加载过程：
1. 加载阶段
2. 链接阶段
3. 初始化阶段

类加载器子系统的作用：从文件系统或网络中加载class文件。

ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。

加载类信息存放于方法区的内存空间。不仅如此，方法区还会存放运行时常量池信息和包括字符串字面量和数字常量(这部分常量信息是Class文件中常量池(constant pool)部分的内存映射)。

![](../JVM_Pictures/Snipaste_2022-01-30_16-18-29.png)
1. class file存在于本地硬盘上，最终执行的时候是要在JVM中根据这个文件实例化出n个一摸一样的实例。
2. class file加载到JVM中，被称为DNA元数据模板，放在方法区。
3. 在.class文件 -> JVM -> 最终成为元数据模板，此过程就需要一个运输工具(类装载器 Class Loader)，扮演一个快递员的角色 (这个加载方式是通过二进制流的方式加载进来的)。

![](../JVM_Pictures/Snipaste_2022-01-30_16-25-05.png)

## 2.1 Loading阶段
1. 通过一个类的全限定名获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化味方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类对各种数据的访问入口。
4. 加载.class的方式：
   1. 从本地系统中直接加载
   2. 通过网络获取，典型场景：Web Applet
   3. 从zip压缩包中读取，成为日后jar、war格式得基础
   4. 运行时计算生成，使用最多的是：动态代理技术
   5. 由其他文件生成，典型场景：JSP应用
   6. 从专有数据库提取.class文件，比较少见
   7. 从加密文件中获取，典型的防Class文件被反编译的保护措施

## 2.2 Linking阶段
1. 验证(Verify)：
   1. 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。
   2. 四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证。
2. 准备(prepare)：
   1. 为类变量分配内存并且设置该类变量的默认初始值，即零值。
   2. **这里不包含用final修饰的static**，因为final在编译的时候就会分配了，准备阶段会显示初始化。
   3. **这里不会为实例变量分配初始化**，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。
3. 解析(Resolve)：
   1. 将常量池内的符号引用转换为直接引用的过程。
   2. 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。
   3. 符号引用就是一组符号来描述所引用的目标。负号引用的字面量形式明确定义子java虚拟机规范的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
   4. 解析动作主要针对类、接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。

## 2.3 Initialization阶段
1. 初始化阶段就是执行类构造器方法<clinit>()的过程。
2. 此方法不需要定义，是javac编译器**自动收集类中的所有类变量的赋值动作和静态代码块中的语句**合并而来。(有赋值这类动作，<clinit>()才存在，否则就不存在)
3. 构造器方法中指令按语句源文件中出现的顺序执行。
4. <clinit>()不同于类的构造器。(关联：构造器是虚拟机视角下的<init>())
5. 若该类具有父类，JVM会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完毕。
6. 虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁。

## 2.4 类加载器分类

1. JVM支持两种类型的加载器，分别为**引导类加载器 (Bootstrap ClassLoader)** 和 **自定义类加载器(User-Defined ClassLoader)**
2. 从概念上讲，自定义类加载器一般指的是程序中由开发人员自定义的一类加载器，但是Java虚拟机规范却没有这么定义，而是**将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器**。
3. 无论类加载器的类型如何划分，在程序中最常见的类加载器始终只有三个：
![](../JVM_Pictures/Snipaste_2022-03-06_15-18-45.png)
![](../JVM_Pictures/Snipaste_2022-03-06_15-19-35.png)

简单查看下类加载器
```java 

```

### 虚拟机自带的加载器
1. 启动类加载器 (引导类加载器，Bootstrap ClassLoader)
a. 这个类加载使用 C/C++语言实现，嵌套在JVM内部
b. 它用来加载Java核心库 (JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容)，用于提供JVM自身需要的类
c. 并不继承自java.lang.CLassLoader，没有父加载器
d. 加载扩展类和应用程序类加载器，并指定为他们的父类加载器
e. 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类
2. 扩展类加载器 (Extension ClassLoader)
a. Java语言编写，由sun.misc.Launcher$ExtClassLoader实现
b. 派生于ClassLoader类
c. 父类加载器为启动类加载器
d. 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录 (扩展目录) 下加载类库。**如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载**
3. 应用程序类加载器 (系统类加载器 AppClassLoader)
a. Java编写，由sun.misc.Launcher$AppClassLoader实现
b. 派生于ClassLoader类
c. 父类加载器为扩展类加载器
d. 它负责加载环境变量classpath或系统属性 java.class.path制定路径下的类库
e. 该类加载是程序中默认的类加载器，一般来说，java应用的类都是由它类完成加载
f. 通过ClassLoader#getSystemClassLoader() 方法可以获取该类加载器

### 用户自定义类加载
在java的日常应用程序开发中，类的加载几乎是由上述3种类加载器的相互配合执行的，在必要时，还可以自定义类加载器，来定制类的加载方式

为什么要自定义类加载器？
1. 隔离加载类 (比如，避免类的冲突，不同包可能有一样的名字)
2. 修改类加载的方式
3. 扩展加载源
4. 防止源码泄露

用户自定义类加载器实现步骤：
1. 通过继承抽象类 java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求
2. 在jdk1.2前，自定义类加载器需要继承ClassLoader类并重写loadClass()方法。但是在1.2之后，不需要重写loadClass()，而是吧自定义的类加载逻辑编辑在findClass()中
3. 在没有复杂的需求，可以直接继承URLClassLoader类，这样可以避免自己编写findClass()方法及其获取字节码流的方式，使用自定义类加载器编写更简洁

``` java

```

**关于ClassLoader**
它时一个抽象类，其后所有的类加载器都继承自ClassLoader (不包括启动类加载器)
![](../JVM_Pictures/Snipaste_2022-03-06_17-45-17.png)
![](../JVM_Pictures/Snipaste_2022-03-06_15-19-35.png)

获取ClassLoader的途径
![](../JVM_Pictures/Snipaste_2022-03-06_17-46-58.png)

### 双亲委派机制

Java虚拟机对class文件采用的是**按需加载**的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，java虚拟机采用的是双亲委派机制，**即把请求交由父类处理，它是一种任务委派模式**

工作原理：
1. 如果一个类加载器收到类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行
2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将达到顶层的启动类加载器
3. 如果父类加载器可以完成加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。
![](../JVM_Pictures/Snipaste_2022-03-06_18-00-22.png)

例子1：String
```java

```

举例2：
![](../JVM_Pictures/Snipaste_2022-03-06_18-04-42.png)

双亲委派机制的优势:
1. 避免类的重复加载
2. 保护程序安全，防止核心API被随意篡改
a. 自定义类: java.lang.String
b. 自定义类: java.lang.ShkStart

双亲委派机制拓展：**沙箱安全机制**

自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件 (rt.jar包中java\lang\String.class)，报错信息说没有main方法，就是因为加载的rt.jar包中的String类。这样可以敢保证对java核心源代码的保护，这就是**沙箱安全机制**

### 拓展

在JVM中表示两个Class对象是否为同一个类存在的两个必要条件：
1. 类的完成类名必须一致，包括包名。
2. 家在这个类的ClassLoader (指ClassLoader实例对象) 必须相同

换句话说，在JVM中，即使两个类对象来源于同一个class文件，被用一个虚拟机所加载，但是只要加载他们的classLoader实例对象不同，那么他们两个类的对象也是不相等的

JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。由用户类型加载器加载的，那么jvm会**将这个类加载器的一个引用作为类型信息的一部分保存在方法区中**。当**解析一个类型到另一个类型的引用**的时候，jvm需要**保证这两个类型的类加载器是相同的**。

**类的主动使用和被动使用**:

1. 主动使用：
a. 创建类的实例
b. 访问某个类或接口的静态变量，或者对该静态变量赋值
c. 调用类的静态方法
d. 反射
e. 初始化一个类的子类
f. Java虚拟机启动时被标明为启动类的类
g. jdk7开始提供的动态语言支持
2. 除了这7种情况，其他使用java类的方式都被看作是**对类的被动使用**，都**不会到之类的初始化**

二 自动内存管理
====

2 Java内存区域与内存溢出异常
----

## 2.1 运行时数据区
JVM在执行java程序的时候把其管理的内存划分为不同的数据区域。（不同区域用途不同，创建时间、销毁时间也不相同）

* 所有线程共享区域：method area, heap
* 线程隔离的数据区：vm stack, native method stack, program counter register

### 2.1.1 程序计数器

它是一块较小的内存空间，很多基础功能（分支、循环、跳转、异常处理、线程恢复等）都依赖program counter register。它是指示器，字节码解释器就是通过其值来选取下一条要执行的字节码指令。

虚拟机多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的。我为了保证线程切换恢复到正确的执行位置，因此，每个线程都需要一个独立的program counter register，各自的pcr独立存储互不影响。

pcr只会在线程执行java方法的时候才会记录正在执行的虚拟机字节码指令地址。如果线程执行的是本地方法，那计数器值就是空（undefined）。

pcr的内存区域是为一个在虚拟机规范中没有任何OutOfMeoryError情况的区域。

### 2.1.2 Java虚拟机栈

同pcr一样，java vm stack也是线程私有的。其生命周期与线程相同。它是java方法执行的内存模型（执行native method不会被创建）。每个方法被执行时，jvm会同步创建一个 Stack Frame（方法运行期重要的基础数据结构） 用于存储局部变量表、操作数栈、动态连接、方法出口等信息。一个方法从调用到执行完毕，对应着一个stack frame 栈帧在jvm中从出栈到入栈的过程。

java内存区不止笼统的heap和stack。与对象内存分配最密切的却是这两个部分。stack通常指的就是vm stack，或更多情况下只是vm stack中局部变量表部分。

**局部变量槽：**

栈中局部变量表存放了编译期各种基本数据类型、对象引用（reference类型，不等同于对象本身，可能是指向对象起始地址的引用指针，或是指向代表对象的句柄或与对象有关的位置）、returnAddress类型（指向了一条字节码指令的地址）。

这些数据类型在局部变量表中的存储空间以**局部变量槽**（slot）来表示，其中，64位的long和double数据会占用两个变量槽，其余数据占一个。

它所需的内存空间在编译期间完成分配，当进入一个方式时，其所需要在stack frame中分配多大的局部变量空间时完全确定的，方法运行期间不会改变局部变量表的大小（指的是变量槽的数量）。

vm stack 规定了两种异常，StackOverflowError（当线程请求的栈深度大于jvm所允许的深度时）、OutOfMemoryError（当
栈容量动态扩展（hotspot不支持动态扩展，所以不会报此异常）时无法申请到足够的内存时）。

### 2.1.3 本地方法站 

native method stacks与vm stack二者作用相似，前者执行 native method服务（比如c/c++），后者执行字节码。

本地方法也会在栈深度溢出或栈扩展失败时爆出StackOverflowError、OutOfMemoryError。

### 2.1.4 Java Heap

堆是jvm管理内存最大的一块，也是被所有线程共享的、jvm启动时被创建。其存在的唯一目的就是存放对象实例，几乎所有的对象实例都在此分配内存。

Java堆是垃圾收集器管理的内存区，也叫CG堆（Garbage Collected Heap）。随着垃圾收集器技术的进步，是否还分为新生代、老年代、永久代等就有待商榷了。

从内存分配角度看，所有线程共享堆中可以划分为分配缓冲区（Thread Local Allocation Buffer. TLAB），以提升对象分配效率。不管如何，**堆中存储的只能是对象的实例**。

Java堆被细分的目的只是为了更好地回收内存、更快地分配内存。

Java堆可以处于物理上不连续但逻辑上连续的内存空间中。它的大小可以固定可以扩展，主流jvm是可扩展（通过-Xmx -Xms设置），如果堆中没有内存完成实例分配且无法扩展时，会抛出OutOfMemoryError异常。

### 2.1.5 Method Area

同Java堆一样是线程共享的内存区域，但它用来存储已经被加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。别名非堆（non-heap），目的是与java堆区分开。

方法区并不等于永久代，只是HotSpot设计初把收集器分代扩展至方法区了。这种设计有它的好处，但更容易造成内存溢出。

垃圾收集行为在这个区域比较少出现，出现了后其内存回收目标主要是针对常量池的回收和对类型的卸载。

方法区无法按满足新内存分配需求会抛出OutOfMemoryError异常。

### 2.1.6 运行时常量池

Runtime Constant Pool是Method Area的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池表（Constant Pool Table），用于存放编译期生成的个种字面量与符号引用，这部分内容会在类加载后存放到Method Area的Runtime Constant Pool。

Runtime Constant Pool具备动态性，因为常量不一定只有编译期才能产生，也就是说，不只是在Class文件预置入才会进入到运行时常量池，在运行期间也可以加入新的常量到池中。常见的就是String类的intern()方法。

当常量池无法再申请到内存会抛出OutOfMemoryError。

### 2.1.7 直接内存

Direct Memory不是jvm运行时数据区的一部分，但是经常被使用到。NIO引入了一种基于Channel与Buffer的IO方式，可以直接使用Native函数库直接分配堆外内存，通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样会提升性能、避免在Java堆和Native堆中来回复制数据。

Direct Memory的分配不受Java堆大小的限制，但是受限于总机内存。操作不当（虚拟机运行区内存+直接内存大于总机内存）会导致动态扩展时出现OutOfMemoryError。

## 2.2 HotSpot虚拟机对象探秘

### 2.2.1 对象的创建

1. Jvm接收到字节码new指令时，首先检查该指令的参数是否能在常量池中找到类的符号引用，并且检查该符号引用代表的类是否被加载、解析和初始化过。如果没有，就先执行相应的类加载过程。

2. 类加载检查通过后，jvm给新生对象分配内存，其内存所需的大小在类加载完成后便可确定，而为对象分配空间的任务实际上就是把一块确定大小的内存从Java堆中划分出来。分配方式有Java堆是否规整决定，而Java堆的规整又由采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定。
   * 假设Java堆中内存绝对规整，所有使用过的内存在一边，空闲内存在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为指针碰撞（Bump The Pointer）。
   * 假设Java堆中内存不规整，已使用内存和未使用内存相互交错在一起，就无法简单地指针碰撞，jvm必须维护一个列表，上面记录哪些内存块可用，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为空闲列表（Free List）
3. 对象在jvm的创建是复杂的行为，仅仅修改指针指向的位置，在并发下会存在线程安全问题，如给对象A分配内存，指针还未来得及修改，对象B同时使用了原来的指针来分配内存的情况。
   * 解决方法1：对分配内存空间的动作进行同步处理，JVM采用的是CAS配上失败重试的方式保证更新操作的原子性。
   * 解决方法2：把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），不同线程分配内存，就在其对应的的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。否使用了TLAB的命令：-XX: +/-UseTLAB参数。
   * 内存分配完之后，jvm必须将分配的内存空间（不包括对象头）都初始化为零值。如果使用了TLAB，这个操作也可以提前至TLAB分配时进行。这是为了保证对象的实例字段在java代码中可以不赋初始值就直接使用，使程序能够访问到这些字段的数据类型所对应的零值。
4. jvm还要对对象进行必要的设置，如确定该对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息会存在对象头（Object header）中，根据jvm当前运行状态的不同，对象头会有不用的设置。
5. jvm角度来看，新的对象就产生了。但从java程序视角，对象创建才刚刚开始——构造函数，即Class文件中的<init>()方法还没有执行，所有字段都是默认的零值。对象所需要其他资源和状态信息也都没有构造好。

### 2.2.2 对象的内存布局

HotSpot中，对象在堆内存的存储布局：对象头 Header、实例数据 Instance Data、对齐填充 Padding。
* Header：一部分存储对象运行时数据，如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，称为Mark Word。它是一个动态定义的数据结构，以便在极小的空间存储尽量多的数据。
* Header：另一部分存储类型指针，即对象指向它的类型元数据的指针，jvm通过指针确定对象是哪个类的实例。并不是所有jvm的实现都必须在对象数据保留类型指针，换句话说，查找对象的元数据不一定要经过对象本身。如果对象是数组，那么对象头必须有一块记录数组长度的数据，jvm通过元数据来确定对象的大小，因此长度是要确定的。
* Instance Data：存储着对象真正存储的有效信息，即代码程序中定义的各类型字段内容，无论从父类继承还是子类中定义的字段都必须记录下来。这部分存储顺序收到虚拟机分配策略参数（-XX: fieldsAllocationStyle参数）和字段在java源码中定义顺序的影响。
* Padding：这不是必然存在的，也没有特别含义，仅仅起着占位符的作用。HotSpot自动内存管理系统要求对象起始地址必须是8字节的整数倍，，对象头部分是被设计过正好是8字节的倍数，而对象实例数据部分如果没对齐，就需要其来补全。

### 2.2.3 对象的访问定位

Java程序通过栈上的reference数据来操作堆上的具体对象。主流对象访问方式为句柄和直接指针两种：图P86
1. 句柄访问，Java堆划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄包含了对象实例数据（存储在堆中的实例池）与类型数据（存储在方法区）各自的地址信息。优势：稳定句柄地址，对象被移动时，只会改变句柄中的实例数据指针，而reference本身不需要修改。
2. 直接指针，Java堆中对象的内存布局必须要考虑如何访问类型数据的相关信息，reference中存储的直接就是对象地址。优势：速度快、节省一次指针定位的开销（因为它直接存储的对象实例地址，不需要存储对象实例地址的指针），这部分时间开销是非常可观的。

## 2.3 OutOfMemoryError
除了程序计数器，jvm内存的其他几个运行区域都有发生OOM的可能。

### 2.3.1 Java堆溢出

随着不断地创建对象并且不清除，随着对象数量增加，总容量达到最大堆的容量限制就会OOM。

操作指令和代码测试在P90

要解决Java堆内存区域的异常，一般都是通过内存映像分析工具对Dump出来的堆转储快照进行分析，第一步要确认导致OOM的对象是哪个，然后分清是内存泄漏（memory leak）还是内存溢出（memory overflow）
* 内存泄漏，通过工具查看泄露对象到GC Roots的引用链，找到泄露对象通过怎样的引用路径、与哪些GC Roots相关联，才导致无法回收。根据泄露对象的类型信息以及它到GC Roots引用链的信息来定位它创建的未知，进而找到产生内存泄漏的代码的具体位置。
* 内存溢出，就表示内存中的对象都是存活的，就该检查jvm的堆参数设置（-Xmx\-Xms）与机器内存对比，看看是否还有向上调整的空间。代码上检查是否存在生命周期过长、持有状态时间过长、存储结构设计不合理等情况，减少程序运行的内存消耗。

### 2.3.2 虚拟机栈和本地方法溢出

HotSpot并不区分vm栈和native方法栈，因此，-Xoss参数是没有作用的，栈容量智能有-Xss参数来设定。

栈中有两种异常：StackOverFlowError（线程请求的栈深度超过jvm允许的最大深度时）、OutOfMemoryError（扩展栈容量时无法申请到足够的内存时）。

Java虚拟机规范中允许jvm自行实现栈的动态扩展，而HotSpot的选择是不支持，所以除非在创建线程申请内存时就因无法获得足够内存而出现OOM，否则线程运行期间是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError。

验证：
1. 使用-Xss参数减少栈内存容量。结果，抛出StackOverflowError，异常出现时输出的堆栈深度相应缩小。
2. 定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果，抛出StackOverflowError，异常出现时输出的堆栈神父相应缩小。

### 2.3.3 方法区和运行时常量池区溢出

运行时常量池是方法区的一部分，方法区溢出也是常见的异常。


### 2.3.4 本机直接内存溢出

3、垃圾回收器与内存分配策略
----


## 3.1 概述
GC关注的是Java堆和方法区的内存管理，因为这两个区有着显著的不确定性，它们的内存分配和回收是动态的：一个接口的多个实现类需要的内存可能不一样；一个方法所执行的不同条件分支所需要的内存也可能不一样；只有处于运行期间，才知道程序究竟会创建哪些对象，多少个对象。

## 3.2 对象已死
垃圾收集器在对堆进行回收前，就是确定对象是存活还是死亡。

### 3.2.1 引用计数算法

Reference Counting原理：在
* 每个对象中添加一个引用计数器
* 每当有一个地方引用它时，计数器值+1
* 当引用失效时，计数器值-1
* 任何时刻计数器为0的对象就是不可被引用

大多数情况下，reference counting是一个不错的算法（原理简单、判定效率高，虽然占用了一些额外的内存空间来进行记数）。但是在Java主流的jvm中没有选用该算法管理内存，主要原因是，该算法必须要配合大量额外处理才能保证正常工作，譬如单纯的引用计数就很难解决**对象之间互相循环引用**的问题。

objA和objB在互相引用，但是他们本身的属性只有一个instance并且是null，赋值令各自的instance = 对象obj。两个对象已经不可能再被引用了：
* 因为他们的各自的obj都是null，可以看到除了instance剩下的属性都是private，而instance是null。当值为null的时候，就表示它已经是失效的了。

但是二者又互相引用对方，导致它们的计数都不为0，所以，通过引用计数算法就无法回收他们。而通过内存回收日志可以看到，jvm并没有二者相互引用就放弃回收他们，侧面证明了，jvm不是通过引用计数算法来判断对象是否存活。

```java
/**
 * testGC()方法执行后，ab会不会被GC？
 */
public class ReferenceCountingGC {

    public Object instance = null;

    private static final int _1MB = 1024 * 1024;

    /**
     * 唯一充裕就是占内存，以便在GC日志中看清楚是否被回收过
     */
    private byte[] bigSize = new byte[2 * _1MB];

    public static void testGC(){
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;

        // 假设在这行发生GC，a、b是都能被回收
        System.gc();
    }

    public static void main(String[] args) {
        testGC();
    }

}
```

### 3.2.2 可达性分析算法 Reachability Analysis (Java用的)

算法思路：通过 GC Roots 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链” Reference Chain，如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论的话来说就是从 GC Roots 到这个对象不可达时，该对象是可能再被使用的。

固定可作为 GC Roots 的对象包括一下几种“
* 在vm stack（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
* 在method area 中类静态属性引用的对象、譬如Java类的旖旎用类型静态变量。
* 在method area 常量引用的对象，譬如字符串常量池（String table）里的引用。
* 在本地方法栈中 JNI（即 Native方法）引用的对象。
* jvm内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象。（NullPointException、OutofMemoryError）等，还有系统类加载器。
* 所有被同步锁（synchronized关键字）持有的对象。
* 反应jvm内部却情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

最新的垃圾收集器欧具备了局部回收的特征，为了避免GC Roots包含过多对象而过度膨胀。

### 3.2.3 再谈引用

引用如果只有未被引用和被引用就很狭隘，比如有些对象，我们希望当内存足够时就保留，内存不足就优先释放。

* Strongly Reference：传统的引用定义，引用复制，类似 Object obj = new Object();，这种关系下，垃圾收集器永远不会回收被引用对象。
* Soft Reference：引用有用但非必须的对象
  * 内存溢出异常前，会把回收这些对象进行二次回收，这次回收后还没有足够内存才会抛出异常。
* Weak Reference：比软引用更弱一下，弱引用关联的对象只能存活到下一次垃圾收集发生为止。
* Phantom Reference：最弱的引用关系。
  * 存在目的：对象被收集器回收时收到一个系统通知。 
  * 对象是否有虚引用，完全不会对其生存空间构成影响，也无法通过虚引用来取得一个对象实例。

### 3.2.4 生存还是死亡

可达性分析算法判定对象死亡的流程：
1. 发现对象与GC Roots没有引用链，被标记一次
2. 二次筛选，筛选条件是对象是否有必要执行 finalize()方法
3. 对象没有覆盖finalize()方法或该方法被jvm调用过，则视为生存
4. 对象被判定为有必要执行finalize()方法，该对象会被防止在F-Queue的队列中
5. jvm随后会自动建立一个低优先级的 Finalizer线程去执行队列中对象的 finalize()方法。（注：执行表示jvm会触发方法运行，但是不承诺会等到其运行结束）如果某个对象的finalize()方法执行慢，甚至死循环，就会导致整个队列永久性等待，甚至内存回收子系统崩溃
6. 垃圾收集器会对F-Queue中的对象进行二次标记，如果对象在调用finalize()中重新与引用链上的任何一个对象建立关联就会被视为生存，也就会被移除该队列。
7. 没有和引用链建立关联的对象会被回收。

总结：对象被回收需要经过两次标记，自救的机会只有一次，就是在第一次和第二次标记中用过finaliza()建立与引用链上的对象的关联即可。

```java
/**
 * 对象被GC时的自我拯救
 */
public class FinalizeEscapeGC {

    public static FinalizeEscapeGC SAVE_HOOK = null;

    public void isAlive(){
        System.out.println("yes, i am still alive :>");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws InterruptedException {
        SAVE_HOOK = new FinalizeEscapeGC();

        // 对象第一次拯救自己
        SAVE_HOOK = null;
        System.gc();
        // Finalizer方法优先级低，暂停0.5s等它
        Thread.sleep(500);
        if(SAVE_HOOK != null){
            SAVE_HOOK.isAlive();
        }else {
            System.out.println("no, i am dead :<");
        }

        // 代码完全相同，只为证明它只能拯救一次
        // 对象第二次拯救自己
        SAVE_HOOK = null;
        System.gc();
        // Finalizer方法优先级低，暂停0.5s等它
        Thread.sleep(500);
        if(SAVE_HOOK != null){
            SAVE_HOOK.isAlive();
        }else {
            System.out.println("no, i am dead :<");
        }

    }
```

运行结果
```
finalize method executed!
yes, i am still alive :>
no, i am dead :<
```
并不鼓励使用这种方式来拯救对象，并且要尽量避免使用它（虽然已经使用它）

重点：finalize()已经被弃用。

finalize()的弊端，一方面无法知道对象在F-Queue中的顺序，而是没办法空值GC发生的时间。因此通过该方法释放资源是危险的。

更好地代替方式：try-with-resources 代码块 和 AutoCloseable 接口来确保资源在代码块执行完毕之后被释放。

或者使用 PhantomReference虚引用 来实现对象被回收时触发的动作。

### 3.2.5 回收方法区

jvm规范中提到可以不要求jvm在method area中实现垃圾收集，
* 如hotspot中元空间或永久代
* 方法区垃圾收集的性价比低（因为java堆中，尤其新生代中，一次能回收70%-99%的内存），而方法区回收的判定条件一般比较苛刻

方法区垃圾收集主要两部分内容：
1. 废弃常量，回收过程与对象类似。如果没有被引用就会回收。
2. 不再使用的类型，但是判定类型是否不再被使用条件苛刻，需同时满足3个条件：
   1. 该类所有的实例已被回收
   2. 加载该类的类加载器被回收（很难达成）
   3. 该类对应的class对象没有被引用，也无法通过反射访问

## 3.3 垃圾收集算法

### 3.3.1 分代收集理论
主流垃圾收集器大多遵循 分代收集 Generational Collection的理论，它联立在两个假说之上：
1. 弱分代假说 weak generatiinal hypothesis：绝大多数对象都是朝生夕灭
2. 强分代假说 strong generational hypothesis：熬过越多次垃圾收集的对象就越难消亡

根据假说得到的设计原则：将java堆分出不同的区域并根据对象年龄分配到不同区存储。在jvm中至少会分为“
1. 新生代 young generation，大批对象死去，每次回收后存活的少量对象，将晋升到老年代中存放。
2. 老年代 old generation

第三条假说：跨代引用假说 intergeneraational reference hypothesis（相比于同代引用占比极小），引入该假说的原因是：在新生代中存在一些不被新生代引用但却被老年代引用的对象，内存回收中需要考虑这种情况。

名词解释：
* 部分收集 partial GC：目标不是完整收集整个java stack的垃圾回收，其中又分为：
  1. 新生代收集 minor GC / young GC
  2. 老年代收集 major GC / old GC：目前只有 CMS收集器会有单独的老年代
  3. 混合收集 mixed GC：收集整个新生代以及部分老年代的垃圾收集，目前只有G1收集器有
  4. 整堆收集 full GC：收集整个java stack 和 method area的垃圾收集

### 3.3.2 标记-清除算法 mark-sweep
最早也是最基础的垃圾收集算法，先标记后清除，
* 缺点：执行效率不稳定，效率随着对象数量的增加成反比；内存空间碎片化，标记、清除都会产生不连续的内存碎片

### 3.3.3 标记-复制算法（基于半区复制算法 semispace copying） 
为解决标记清除算法效率低而创造，原理是，将可用内存划分出相等两块，每次只使用其中一个。如果内存用完了，就将上面存活的对象复制到另一个内存上，然后把该内存空间都清理掉。
* 优点，完美解决标记清除算法面对大量清除对象时的低效问题
* 缺点，内存空间浪费。

但实际使用中，新生代98%的对象都逃不脱第一轮收集，因此，并不需要 1:1 来划分新生代内存空间。

更优化的半区复制分代策略： Appel式回收
* 思路：把新生代分为一大（eden）二小（survivor）的空间，每次分配内存只是有eden和其中一个survivor。垃圾回收时将这两个存活的对象一次性复制到另一个survivor上，然后清除这两个空间。HotSpot上默认分配的二者空间比例是 8:1。
* 空间利用率：每次新生代占整内存空间的90%，剩下10%是一个survivor，等着备用。
* 逃生门安全设计：当survivor内存空间不足以容纳eden和另一个survivor上的对象时，就依赖其他内存空间进行**分额担保 handel promotion**。

### 3.3.4 标记-整理算法 mark compact
解决标记复制算法对对象存活率较高而进行较多的复制导致效率低的问题（针对老年代对象的死亡特征）。

* 思路：标记和前面一样，后续步骤不是直接对回收对象清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。

标记清除和标记整理的本质差异：后者是前者的移动式回收。

移动式的风险决策：
* 在有大量对象存活的老年代区，移动它们并更新所有引用是一个极为负重的操作，移动过程中必须全程暂停用户应用程序才可进行，被称为 stop the world。
* 完全不考虑移动和整理存活对象，会造成空间碎片化问题，只能依赖复杂的内存分配器和内存访问器来解决。如果负担太大，会影响应用程序的吞吐量。

## 3.4 HotSopt算法细节的实现
该章节主要是为了介绍各款垃圾收集器做前置知识铺垫。

### 3.4.1 根节点枚举
根枚举节点：找出所有的 GC Roots（主要在全局性的引用，如常量或类静态属性，与执行上下文，如栈帧中的本地变量表）

弊端：根节点枚举是必须暂停用户线程的，stop the world困扰。它必须在一个能够保障一致性的快照中才能进行，一致性指的是：
* 整个枚举期间，不会出现根节点集合的对象引用关系还在不断变化，这是分析准确性的标准。这也是导致垃圾回收过程中必须停顿所有的用户线程的重要原因。

实际中，HotSpot在用户线程停顿下来后，也并不会全都检查完，它使用了**OopMap**的数据结构用于枚举 GC Roots，将外部记录下类型信息，存成映射表。生成的方式就是遍历原始映射表/对象，得到一个个偏移量，取偏移量上的类型数据存到oppmap上。

OopMap的协助下，hotspot可以快速准确地完成 GC Roots枚举。

### 3.4.2 安全点
理论上，每一条指令都生成对应的OopMap，就会需要大量额外存储空间，空间成本增加。

实际上，hotspot并没有每条指令生成一个OopMap，只是在特定位置记录这些信息，这个位置就被称为 安全点 Safepoint。

限制条件：程序执行时，不是在任意代码指令流都能停顿下来进行垃圾回收，而是强制必须在安全点才能够暂停。

安全点的标准：选定点不能太少，因为选的太少就会导致每次收集等待时间过长；也不能频繁，以至于增加运行时内存负荷。遵守以“是否具有让程序长时间执行的特征”来选定。长时间执行的特征就是指令序列的复用，如方法调用、循环跳转、异常跳转等，这种指令才会产生安全点。

如何在发生垃圾收集时让所有线程（除JNI调用的线程）都跑到最近的安全点并停顿下来。这里有两个选择：
1. 抢先式中断 preemptive suspension（几乎弃用）：执行代码不用关注中断问题，系统会在GC时，把线程中断，如果有不在安全点的线程，就恢复其线程执行，然后过一会再重新中断，知道全都在安全点上。
2. 主动式中断 voluntary suspension：中断线程时，不对线程操作，只设置一个标志位，各线程执行中会不停地主动轮询该标志，如果是中断标记为真，线程就在最近的安全点主动中断挂起。轮询标志点和安全点是重合的。

### 3.4.3 安全区域 Safe Region

安全点机制保证了程序执行时，如何停顿用户线程，让jvm进去垃圾回收状态的问题。

程序不执行（线程无法响应jvm中断的请求）时，怎么办？
* 安全区域可以解决，它是能够确保在某一段代码中，引用关系不会变化，因此，该区域中任意地方开始垃圾回收都是安全的。通俗理解，安全区域就是被扩展拉伸了的安全点。
* 实现：线程执行到安全区，首先会表示进入到安全区，jvm在垃圾收集时会忽略已经声明在安全区的线程。这些线程要离开安全区域时，就要检查jvm是否完成了 根节点枚举，如果完成就继续执行，否则就一直等待直到收到信号。

### 3.4.4 记忆集与卡表 Remembered Set & Card Table
Remembered Set是为了解决对象跨代引用所带来的问题而在新生代中建立的数据结构（跨域不局限于新生代和老年代之间）。
* 作用：避免把整个老年代加进 GC Roots 扫描范围（缩减GC Roots扫描范围）
* 原理：一种记录从非收集区指向收集区的指针集合的抽象数据结构。（不考虑效率和成本的实现方式是，一个用非收集区中所有含跨代引用的对象数组）
* 实现方案：
  * 记录全部含跨代饮引用对象的空间引用和维护成本高昂。
  * 在垃圾收集场景中国，只需要通过记忆集判断某一块非收集区域是否存在有指向了收集区域的指针即可。
  * 实现记忆集因此选择更为粗犷的记录粒度来节省记忆集的存储和维护成本，列举一些记录精度：
    1. 字长精度：每个记录精确到一个机器字长（处理器的寻址位数，如32位或64位，此精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。
    2. 对象精度：每个记录精确到对象，该对象里有字段含有跨代指针。
    3. 卡精度：每个记录精确到一个块内存区域，该区域内有对象含有跨代指针。

其中，卡精度是最常用的记忆集实现形式，它由卡表（Card Table）的方式来实现。（注：卡表 不等于 记忆集，记忆集只是一种抽象的数据结构，抽象指的是只定义了记忆集的行为意图，并没有定义其行为的具体实现）卡表就是记忆集的以中国具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。

卡表和记忆集的关系就好比HashMap和Map的关系。

卡表最简单的形式：一个字节数组；选用 byte[]而不是bit[]，主要是因为速度，计算机硬件都是按照最小按字节寻址，没有直接存储bit指令。

解析字节数组card table：其中的每个元素都对应其标识的内存区域中一块特定大小的内存块，这个内存卡块被称为卡页（card page）。通常，卡页大小都是2的N次幂的字节数，比如 2^9，就是512字节。

一个卡页的内存通常包含不止一个对象，只要卡页内有对象的字段存在着跨代指针，那就将对应的卡表的数组元素标识为1，称这个元素变脏（dirty），没有则标识为0。在GC时，只要筛选出标识为1的元素，就能得到哪些卡页内存块中包含跨代指针，把他们加入到GC Roots中一并扫描。

### 3.4.5 写屏障 Write Barrier

* 卡表存在的问题：
  * 问题1，何时变脏：前置条件，其他分代区域中对象引用了本区域对象时，卡表元素变脏；变脏时间点，原则上发生在引用类型字段赋值的那一刻。
  * 问题2，如何变脏（即如何在对象赋值的那一刻更新维护卡表）：
    * 场景1（解释执行的字节码）：相对好处理，jvm负责每天字节码指令的执行，有充分的介入空间。
    * 场景2（编译执行的场景）：即时编译后的代码是纯粹的机器指令流，必须通过机器码层面的手段，把维护卡表的动作放到每一个赋值操作之中。
* 写屏障的作用：解决卡表元素如何维护的问题，例如，何时变脏、谁来把它们变脏等。（维护卡表状态）
* 对写屏障的理解：在JVM层面对"引用类型字段赋值"这个动作的AOP切面，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，即写前屏障（pre-write barrier）、写后屏障（post-write barrier）
* 写屏障的效果：jvm会为所有的赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表的操作，无论更新的是否为老年代对新生代对象的引用，每次只要对引用进行更新，就会额外产生额外的开销，但是这个开销还是远远低于扫描整个老年代的。
* 弊端：
    1. 额外开销
    2. 伪共享（False Sharing）：卡表在高并发场景下会面临的问题，是处理并发底层细节时需要考虑的。处理器的缓存系统多数是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化、同步）而导致性能降低。
       * 假设，处理器缓存行大小64字节，一个卡表元素占1字节，64个卡表元素共享同一个缓存行。它们对应的卡页总的内存就是32kb（64*512字节）。如果不同线程更新的对象正好出于这32kb的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能。
* 解决伪共享：不采用无条件的写屏障；先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏。即先判断 if(card_table != 0){card_table=0} ；参数 -XX: +UseCondCardMark，来决定是否开启卡表更新的条件判断，开启能够避免伪共享问题，但是会增加一次额外判断的开销，二者都有性能损失。


### 3.4.6  并发的可达性分析

* 可达性分析算法理论的前提，全过程都基于一个保障一致性的快照中，才可以进行。也就是说必须全程冻结用户线程的运行。

4、虚拟机性能监控、处理故障工具
----



### 5 